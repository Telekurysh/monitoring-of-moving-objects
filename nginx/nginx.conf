worker_processes auto;
events { worker_connections 1024; }

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    include       /etc/nginx/mime.types;

    # gzip
    gzip on;
    gzip_min_length 1000;
    gzip_proxied any;
    gzip_types text/plain text/css application/json application/javascript application/xml text/xml application/rss+xml image/svg+xml;

    # proxy cache (for static GETs, exclude /api)
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=static_cache:10m max_size=100m inactive=60m use_temp_path=off;

    # Upstreams for GET balancing (weights 2:1:1)
    upstream backend_get {
        server app_main:8000 weight=2;
        server app_read1:8000 weight=1;
        server app_read2:8000 weight=1;
    }

    # Upstream for write operations
    upstream backend_write {
        server app_main:8000;
    }

    # mirror app upstream
    upstream mirror_backend {
        server sensortrack_app_mirror:8000;
    }

    upstream grafana_backend {
        server grafana:3000;
    }


    server {
        listen 80;
        server_name _;
        root /usr/share/nginx/html;
        index static/index.html index.html index.htm;

        # Add application name header on all responses
        add_header X-App-Name "SensorTrackPro" always;

        # status
        location = /status/raw {
            stub_status on;
            access_log off;
        }

        location = /status {
            try_files /status.html =404;
        }

        # Documentation - serve README.md converted to HTML (pre-rendered file)
        location = /documentation {
            try_files /documentation.html =404;
            charset utf-8;
            default_type text/html;
            add_header Content-Type "text/html; charset=utf-8";
        }

        # Legacy - proxy to app interface (keeps previous behaviour)
        location /legacy {
            proxy_pass http://app_main:8000/interface;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Admin (proxy to adminer which connects to postgres)
        location /admin {
            proxy_pass http://adminer:8080/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Serve static content and enable caching for GETs outside /api
        location /static/ {
            proxy_cache static_cache;
            proxy_cache_valid 200 60m;
            proxy_pass http://backend_get; # read-only GETs to backends for static/api assets if needed
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Mirror route: proxy everything under /mirror to the mirror app; preserve prefix
        location ^~ /mirror/ {
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            # Передаём оригинальный URI (не удаляем /mirror/)
            proxy_pass http://mirror_backend;

            proxy_redirect / /mirror/;

            proxy_hide_header Server;
            add_header X-Server-Name "SensorTrackPro" always;

            proxy_http_version 1.1;
            proxy_buffering off;
            proxy_set_header Connection "";
        }

        location = /managment {
            try_files /managment.html =404;
        }

        location /reserved/ {
            try_files $uri $uri/ /static/index.html;
        }

        location = / {
            try_files /static/index.html =404;
        }

        location / {
            try_files $uri $uri/ /static/index.html =404;
        }

        # Proxy Grafana at /monitoring
        location /monitoring/ {
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $http_host;
            proxy_set_header X-Forwarded-Server $host;

            # Preserve the original request URI so Grafana (which serves
            # from /monitoring) sees the correct path.
            proxy_pass http://grafana_backend;

            # Handle WebSocket connections
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Do not perform aggressive proxy_redirect rewriting here.
            proxy_redirect off;
        }

        location ~ ^/api/v[0-9]+/?$ {
            rewrite ^(/api/v[0-9]+)/?$ $1 break;
            proxy_pass http://backend_get$uri/docs;
            proxy_set_header Host $host;
        }

        # API entrypoint: route GETs to weighted upstream, other methods to primary
        location /api/ {
            # If method is GET, use weighted backend pool
            if ($request_method = GET) {
                proxy_pass http://backend_get;
            }

            # All other methods -> write upstream
            if ($request_method != GET) {
                proxy_pass http://backend_write;
            }

            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            # timeouts
            proxy_connect_timeout 5s;
            proxy_read_timeout 60s;
        }

        # Custom error pages / intercept writes attempted on read-only backends
        proxy_intercept_errors on;
        error_page 502 503 504 = /_error_backend;

        location = /_error_backend {
            internal;
            default_type application/json;
            return 503 '{"detail": "Upstream error or read-only node received a write request"}';
        }
    }
}
